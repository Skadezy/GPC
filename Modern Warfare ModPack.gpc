/*
 
This is a Call of Duty Pack.

This script has been taken from the GPC Library and has been edited by Skadezy. 
Most credits are given in sections.

Button Layouts does not work. I have not added it as a feature yet.


*/


// Text to display 

	// Title
	const string TITLE = "MW ModPack"; // 11 char max
	const string TITLE_2 = "Version 1.0": // 11 char max
	
	//DISABLED, ENABLED, SAVED
	const string OFF = "DISABLED"; 
	const string ON = "ENABLED"; 
	const string SAVE= "SAVED";
	
	
	
	//Button Layout
	const string BTN_LAYOUT_0  = "Default";
    const string BTN_LAYOUT_1_FL = "DefaultFL";
    const string BTN_LAYOUT_1  = "Tactical";
    const string BTN_LAYOUT_2_FL  = "TacFL";
    const string BTN_LAYOUT_2  = "Lefty";
    const string BTN_LAYOUT_3  = "N0M4D/Charlie";
    const string BTN_LAYOUT_4  = "N0M4D/Charlie Tac.";
    const string BTN_LAYOUT_5  = "N0M4D/Charlie Left";
    const string BTN_LAYOUT_6  = "Bumper Jumper";
    const string BTN_LAYOUT_7  = "Bumper Jumper Tac.";
    const string BTN_LAYOUT_8  = "1-Hand-Gunslinger";
    const string BTN_LAYOUT_9  = "Stick and Move";
    const string BTN_LAYOUT_10 = "Brawler";
    const string BTN_LAYOUT_11 = "Beast";
    const string FLIPPED       = "Flipped"; 
    
    int btn_layout;

	
	
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

// Mod Name
	const string ANTIRECOIL   = "AntiRecoil";		 // modName_idx = 0
	const string ANTIRECOILH  = "AntirecoilH";       // modName_idz = 1
	const string RAPIDFIRE    = "RapidFire*";        // modName_idx = 2
	const string AKIMBOFIRE   = "AkimboRF";          // modName_idx = 3
    const string SWEETEVIL    = "S.Evil Aim";        // modName_idx = 4		
	const string CRESCENS     = "CrescensAim";       // modName_idx = 5
	const string POLARAIM     = "Polar Aim";         // modName_idx = 6
	const string STICKYAIM    = "Sticky Aim"         // modName_idx = 7 
	const string SNACKSENS    = "SnackSens";          // modName_idx = 8
	const string DROPSHOT     = "DropShot";          // modName_idx = 9
	const string HOLD_BREATH  = "Hold Breath";       // modName_idx = 10
	const string M4ANTI      = "M4 ANTI-R";           // modName_idx = 11
	const string MP5ANTI         = "MP5 ANTI-R";        // modName_idx - 12
	const string UZIANTI     = "UZI ANTI-R";        // modName_idx = 13
	const string AUTOSLIDECANCEL     = "SlideCancel"; // modName_idx = 14
	
	
// Index to find Mod Name string - switchable in game with left/right in ModMenu 
	int modName_idx;

// modName # of the last Mod Name string - Used for cycle modName_idx
	define LAST_MODNAME_STRING = 14;

// # of the last modName_idx that has a value that can be edited
	define LAST_EDITABLE_STRING = 9;
	
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

// Value Name
	// modName_idx = 0 = ANTIRECOIL string
	const string ANTIRECOIL_VERTICAL      = "AR Vertical"; 		 // valName_idx = 0  
	const string ANTIRECOIL_HORIZONTAL    = "AR Horizntl";		     // valName_idx = 1
	// modName_idx = 1
	const string ANTIRECOIL_START         = "AR Start";          // valName_idx = 2
    const string ANTIRECOIL_END           = "AR End";            // valName_idx = 3
    const string ANTIRECOIL_TIME          = "AR Time";           // valName_idx = 4
    const string HORIZONTAL_START         = "HorizStart";        // valName_idx = 5
    const string HORIZONTAL_END           = "HorizEnd";          // valName_idx = 6
    const string HORIZONTAL_TIME          = "HorizTime";         // valName_idx = 7
    // modName_idx = 2
    const string RATE_OF_FIRE             = "Rounds/sec";	     // valName_idx = 8
    // modName_idx = 3
	const string AKIMBOFIRE1              = "Rounds/Sec";        // valName_idx = 9
	// modName_idx = 5
	const string SAMPLINGTIME             = "Sample Time";       // valName_idx = 10
    const string AIMBOOST                 = "Aim Boost";         // valName_idx = 11
    const string AIMCORRECT               = "Correction";        // valName_idx = 12
    const string AIMPERFECT               = "Perfection" ;       // valName_idx = 13
    // modName_idx = 6
    const string INGAMESENS               = "InGameSens";        // valName_idx = 14
    // modName_idx = 7
    const string POLAR_RADIUS            = "Radius";           // valName_idx = 15
    const string POLAR_STEPS              = "Steps";             // valName_idx = 16
    // modName_idx = 8
    const string STICKYAIM_SIZE           = "Sticky Size";       // valName_idx = 17
    const string STICKYAIM_TIME           = "Sticky Time";       // valName_idx = 18
    // modName_idx = 9
    const string GENSENS                  = "GeneralSens";       // valName_idx = 19
    const string ADSSENS                  = "ADS Sens";          // valName_idx = 20
    const string FIRESENS                 = "Fire Sens";         // valName_idx = 21
    const string ADSFIRESENS              = "ADSFireSens";       // valName_idx = 22
    const string GRENADESENS              = "GrenadeSens";       // valName_idx = 23
    // modName_idx = 10
    const string DROPSHOTSPEED            = "Drop Speed"; 
// Index to find Value Name string - switchable in game with left/right in ModEdit 
	int valName_idx;
	
	define AMOUNT_OF_VALNAME_IDX = 24;

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

// /!\ DO NOT CHANGE RATE OF FIRE VALUE IN THE ARRAY
// Constant bytes - VALUES array (mods with value and toggle) - VALUES[line][column]
	const uint8 VALUES[][] = { 		
/* Profile 1 */	{    10,                    0,               10,      20,     24,         0,           0,       0,         1,           1         }}	// profile_idx = 0 
/* Profile 2 */	 	// profile_idx = 1 
             /*                                              
/*		   antirecoil_vertical[], antirecoil_horizontal[]  AR-Start AR-End  AR-Time  Horiz-Start  Horiz-End Horiz-Time  RateOfFire  RateOfFire             
                 AntiRecoil             AntiRecoil                                                                       RapidFire   AkimboRF          
val_col_idx         = 0                   = 1                 = 2    = 3     = 4        = 5          = 6       = 7          = 8        = 9       */

// VALUES array column number - Buffer to add or substract edited value to corresponding value in VALUES array
	int antirecoil_vertical[2]; // antirecoil start value for 3 profiles: profile_idx = 0, 1 and 2 - add this value to the corresponding value in the VALUES array to find your final value
	int antirecoil_horizontal[2];
	int antirecoil_start[2];
    int antirecoil_end[2];
    int antirecoil_time[2];
    int horizontal_start[2];
    int horizontal_end[2];
    int horizontal_time[2];
	int rate_of_fire[2];
	int akimborf[2]; 

/* VALUES array line number - index - 
   Used to define Profiles and also define # of profile to find, edit, and display the right index */
	int profile_idx; 
	
// Index to find VALUES array column - Follow valName_idx to edit the right value (that is in VALUES array or not like Strafe_t value)
	int val_col_idx;

// # of the last column - used in display_edit() function 
	define LAST_EDITABLE_COLUMN = 9;
		
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

// Multi toggles
	int toggle_antirecoil[2];  //NoozBar Standard Anti-recoil 
	int toggle_antirecoilh[2] // Batts Vertical Antirecoil - NoozBar Veritcal & Horizontal Progressive Anti-Recoil
	int toggle_rapidfire[2];  // NoozBar Rapid Fire
	int toggle_akimborf[2];   // ItzSnack Akimbo Rapid Fire
	int toggle_holdbreath[2]; // ItzSnack Hold Breath
	 
	
// Amount of profiles - Used for switch profiles cycle
 
	
// Amount of multi toggle - Used for display profiles
	define AMOUNT_OF_MULTI_TOGGLE = 5;
		
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

// Mods (with values) that activates for all profiles at the same time (if toggled ON)
// Crescens Sticky Aim
   int sticky_aim;
   int stickyaim_size;
   int stickyaim_time;
// SweetEvil 5.3 Aim Abuse
   int sweetevil_on;
   int Sampling_Time;
   int Aim_Boost;
   int Aim_Correction;
   int Aim_Perfection_Limit;
   define POS_Aim_Limit = 70;//70; //75
   define NEG_Aim_Limit = -70;//-70; //75
   define POS_Micro_MVT_Limit = 25;
   define NEG_Micro_MVT_Limit = -25;
   int X_Last_Value     = 0;
   int Y_Last_Value     = 0;
   int X_Current_Value  = 0;
   int Y_Current_Value  = 0;
   int Sampling_Done = FALSE;
   int spiroide_pulse = 0;
   int fine_pulse = 0;
   int Joystick_calibration = FALSE;
   int RX_Axis_Joystick_calibrate = 0; 
   int RY_Axis_Joystick_calibrate = 0;
// Crescens Aim Corrections
   int crescens_aim;
   int ingamesens;
   int ads_grenade_sens;
   int ads_fire_sens;
   int Sens;
// DoNotAtMe Polar Aim Assist
   define X = XB1_RX;                                    
   define Y = XB1_RY;                                    
   define ACTIVE_WHEN_ADS    = TRUE;                     
   define ACTIVE_WHEN_FIRING = TRUE;                     
   int RADIUS;        
   int STEPS;          
   define STEP_INTERVAL =  1;                            
   define VM_INTERVAL   =-2; 
   int time;                                             
   int angle, cos_angle, sin_angle;                      
   int actual_X, actual_Y, actual_Magnitude, max_Magnitude;
   int polar_aim;
   const int8 Polar_Array[]={100,100,100,100,100,100,100,100,99,99,99,99,98,98,97,97,97,96,95,95,94,94,93,92,92,91,90,89,89,88,87,86,85,84,83,82,81,    
   80,79,78,77,75,74,73,72,71,70,69,67,66,65,63,62,61,59,58,56,55,53,52,50,49,47,46,44,43,41,40,38,36,35,33,31,30,28,26,25,23,21,20,18,16,14,13,11,9,7, 
   6,4,2,0,-1,-3,-5,-7,-8,-10,-12,-13,-15,-17,-19,-20,-22,-24,-25,-27,-29,-30,-32,-34,-35,-37,-39,-40,-42,-43,-45,-46,-48,-50,-51,-53,-54,-55,-57,-58,  
   -60,-61,-62,-64,-65,-66,-68,-69,-70,-71,-73,-74,-75,-76,-77,-78,-79,-80,-81,-82,-83,-84,-85,-86,-87,-88,-89,-89,-90,-91,-92,-92,-93,-93,-94,-95,-95, 
   -96,-96,-97,-97,-97,-98,-98,-99,-99,-99,-99,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-99,-99,-99,-98,-98,-98,-97,-97,   
   -96,-96,-95,-94,-94,-93,-93,-92,-91,-90,-90,-89,-88,-87,-86,-85,-84,-83,-82,-81,-80,-79,-78,-77,-76,-75,-74,-72,-71,-70,-69,-67,-66,-65,-63,-62,-61, 
   -59,-58,-56,-55,-53,-52,-50,-49,-47,-46,-44,-43,-41,-40,-38,-36,-35,-33,-31,-30,-28,-26,-25,-23,-21,-20,-18,-16,-14,-13,-11,-9,-7,-6,-4,-2,0,2,4,6,7,
   9,11,13,14,16,18,20,21,23,25,26,28,30,31,33,35,36,38,40,41,43,44,46,47,49,51,52,54,55,56,58,59,61,62,63,65,66,67,69,70,70,72,73,74,75,77,78,79,80,81,
   82,83,84,85,86,87,88,89,89,90,91,92,92,93,94,94,95,95,96,97,97,97,98,98,99,99,99,99,100,100,100,100,100,100,100}; 
// ItzSnacks Custom Sensitivity
   int snacks_sens;
   int GEN_SENS;
   int ADS_SENS;
   int FIRE_SENS;
   int ADS_FIRE_SENS;
   int GRENADE_SENS;
   int USE_SENS;
// ItzSnacks Drop Shot
   int drop_shot;
   int drop_speed;
// EnemyPing & Easy Plates // Credit to who done these codes :) 
   int enemy_ping;
   int easy_plate;
// Toggles
   int mp5comp_on;
   int mp5ar_on;
   int uziAnti_on;
   int AutoSlideCancel_onoff;
  
// slide cancel
int slide_enable = FALSE;

    
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

// Constant bytes - Convert numbers array - ASCII_NUM[column number]
	const uint8 ASCII_NUM[] = 
//	  0  1  2  3  4  5  6  7  8  9  (column numbers)
  	{48,49,50,51,52,53,54,55,56,57};
	
// Variables for function number_to_string() 
	int i;
	int c,c_val;

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

data(
//    Blue      Pink    SkyBlue    Green         
    1,0,0,0,  0,0,0,1,  1,0,1,0,  0,0,1,0,
//   Yellow    White      Red       OFF         
    0,1,1,0,  1,1,1,0,  0,1,0,0,  0,0,0,0 );     
     
// Refresh OLED
	int display_title = TRUE;
	int display_new; 
	int display_black;
    
// ModMenu / ModEdit / KillSwitch
	int ModMenu;	
	int ModEdit;
	int KillSwitch;
	
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

// Anti Recoil values                                                 
	int AntirecoilVertical; 
	int AntirecoilHorizontal;
	int invert; // -1 for inverted, 1 for standard
	int i_val;                                                        
    int i_pnt;                                                        
    int i_num;                                                        
    int i_cnt;                                                        
    int v,ar_y;
	int i_val_h;
    int i_pnt_h;
    int i_num_h;
    int i_cnt_h;
    int v_x,ar_x;
// RapidFire
	int hold_time;                                                    
	int rest_time;
	int led_on;
	int led_off;
// Crescens Double Click I think :/ 
    // Double tap 
    int q;											
    int double__tap[30];
    init {
    while(q < 30) 
    {double__tap[q] = -1;       
    q++;}}
	
// Counter
	int count_black; // for screen saver
// Profiles
	int profile_1or2; // Profile 1 and 2
	
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 
 
init{
// Profile 1
	// Toggles                                                  // Values
	toggle_antirecoil[0]  = get_pvar(SPVAR_1, 0, 1, 0 );        antirecoil_vertical[0]   = get_pvar(SPVAR_6, -99, 99, 0);         
	toggle_antirecoilh[0] = get_pvar(SPVAR_2, 0, 1, 0 );        antirecoil_horizontal[0] = get_pvar(SPVAR_7, -99, 99, 0);
	toggle_rapidfire[0]   = get_pvar(SPVAR_3, 0, 1, 0 );        antirecoil_start[0]      = get_pvar(SPVAR_8,  99, 99, 0);
	toggle_akimborf[0]    = get_pvar(SPVAR_4, 0, 1, 0 );        antirecoil_end[0]        = get_pvar(SPVAR_9, -99, 99, 0); 
    toggle_holdbreath[0]  = get_pvar(SPVAR_5, 0, 1, 0 );        antirecoil_time[0]       = get_pvar(SPVAR_10, -99, 99, 0);                                                           
                                                                horizontal_start[0]      = get_pvar(SPVAR_11, -99, 99, 0); 
                                                                horizontal_end[0]        = get_pvar(SPVAR_12, -99, 99, 0);
                                                                horizontal_time[0]       = get_pvar(SPVAR_13, -99, 99, 0);
                                                                rate_of_fire[0]          = get_pvar(SPVAR_14,  0, 25, 0);
                                                                akimborf[0]              = get_pvar(SPVAR_15,  0, 25, 0);  
	                                                                                
// Profile 2
// Toggles                                                  // Values
	toggle_antirecoil[1]  = get_pvar(SPVAR_16, 0, 1, 0 );       antirecoil_vertical[1]   = get_pvar(SPVAR_21, -99, 99, 0);         
	toggle_antirecoilh[1] = get_pvar(SPVAR_17, 0, 1, 0 );       antirecoil_horizontal[1] = get_pvar(SPVAR_22, -99, 99, 0);
	toggle_rapidfire[1]   = get_pvar(SPVAR_18, 0, 1, 0 );       antirecoil_start[1]      = get_pvar(SPVAR_23,  99, 99, 0);
	toggle_akimborf[1]    = get_pvar(SPVAR_19, 0, 1, 0 );       antirecoil_end[1]        = get_pvar(SPVAR_24, -99, 99, 0); 
    toggle_holdbreath[1]  = get_pvar(SPVAR_20, 0, 1, 0 );       antirecoil_time[1]       = get_pvar(SPVAR_25, -99, 99, 0);                                                           
                                                                horizontal_start[1]      = get_pvar(SPVAR_26, -99, 99, 0); 
                                                                horizontal_end[1]        = get_pvar(SPVAR_27, -99, 99, 0);
                                                                horizontal_time[1]       = get_pvar(SPVAR_28, -99, 99, 0);
                                                                rate_of_fire[1]          = get_pvar(SPVAR_29,  0, 25,  13);
                                                                akimborf[1]              = get_pvar(SPVAR_30,  0, 25, 13);  
// Misc	
// Toggles only													// Values
   sweetevil_on          = get_pvar(SPVAR_31, 0, 1, 0);         Sampling_Time            = get_pvar(SPVAR_42,  1, 10, 10);         
   crescens_aim          = get_pvar(SPVAR_32, 0, 1, 0);         Aim_Boost                = get_pvar(SPVAR_43,  1, 15, 8);       
   polar_aim             = get_pvar(SPVAR_33, 0, 1, 0);         Aim_Correction           = get_pvar(SPVAR_44,  1, 15, 6);
   sticky_aim            = get_pvar(SPVAR_34, 0, 1, 0);         Aim_Perfection_Limit     = get_pvar(SPVAR_45,  1, 60, 30);
   drop_shot             = get_pvar(SPVAR_35, 0, 1, 0);         ingamesens               = get_pvar(SPVAR_46,  1, 20, 0);
   snacks_sens           = get_pvar(SPVAR_36, 0, 1, 0);         RADIUS                   = get_pvar(SPVAR_47,  1, 99, 20);
   enemy_ping            = get_pvar(SPVAR_37, 0, 1, 0);         STEPS                    = get_pvar(SPVAR_48,  1, 99, 15);
   easy_plate            = get_pvar(SPVAR_38, 0, 1, 0);         stickyaim_size           = get_pvar(SPVAR_49,  1, 50, 20);
   mp5comp_on            = get_pvar(SPVAR_39, 0, 1, 0);			stickyaim_time           = get_pvar(SPVAR_50,  1, 99, 20); 
   mp5ar_on               = get_pvar(SPVAR_40, 0, 1, 0);			drop_speed               = get_pvar(SPVAR_51,  1, 250, 60); 	 
   uziAnti_on           = get_pvar(SPVAR_41, 0, 1, 0);	        GEN_SENS                 = get_pvar(SPVAR_52,  1, 327,100);
                                                                ADS_SENS                 = get_pvar(SPVAR_53,  1, 327,100);
                                                                FIRE_SENS                = get_pvar(SPVAR_54,  1, 327,100);
                                                                ADS_FIRE_SENS            = get_pvar(SPVAR_55,  1, 327,100);
                                                                GRENADE_SENS             = get_pvar(SPVAR_56,  1, 327,100);
                                                                btn_layout               = get_pvar(SPVAR_57,  0,11, 0 );
   		
}

							/*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
							|                                                     MAIN SECTION                                                      |
							◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/	
main {
  
key_events(0,0,0,0); // Don't delete otherwise functions will not work.
// Debug - Device Monitor
	set_val(TRACE_1, modName_idx); 
	set_val(TRACE_2, valName_idx); 
	set_val(TRACE_3, profile_idx);
	set_val(TRACE_4, count_black);
	set_val(TRACE_5, RADIUS);
	set_val(TRACE_6, STEPS);
	
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜
// Crossover
    if(get_controller() != PIO_PS4) // If XBOX controller:
    {
        if(get_console() == PIO_PS4) // If PS4 console:
        {
            swap(PS4_SHARE,PS4_TOUCH); // View = TouchPad
        
                if(get_val(PS4_R3) && event_press(PS4_TOUCH)) //  RS + View = ScreenShot
                {
                    set_val(PS4_SHARE,100);
                    set_val(PS4_TOUCH,0);
                    set_val(PS4_R3,0);
                }
        }
	}

  /*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
  |                                                     DISPLAY TITLE                                                     |
  ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/	 

// Display Script Title    
    if(display_title)
    {
    	cls_oled(0);	// clear OLED screen
    	count_black = 0;// reset screen saver counter
    	
    	if(KillSwitch)
    	{
    		printf(center_x(sizeof(OFF) - 1, OLED_FONT_SMALL_WIDTH),8,OLED_FONT_SMALL,OLED_WHITE,OFF[0]);	// display OFF centered in X 
			                                     // display Battery
		}
    	else
    	{
    		printf(center_x(sizeof(TITLE) - 1, OLED_FONT_MEDIUM_WIDTH),13,OLED_FONT_MEDIUM,OLED_WHITE,TITLE[0]);	// display TITLE centered in X 
    	
    	// Display profile name
    		if(profile_idx == 0)
    			printf(center_x(sizeof(TITLE_2) - 1, OLED_FONT_MEDIUM_WIDTH),45,OLED_FONT_MEDIUM,OLED_WHITE,TITLE_2[0]); 
    	
    		
    	
    		display_black = TRUE;	// screen saver
    		display_title = FALSE;
    	}
    }

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜
// Screen saver (OLED off)
    if(display_black && !ModMenu && !KillSwitch)
    {
    	count_black += get_rtime();
    	if(count_black >= 5000)
    	{
    		cls_oled(0);
    		count_black = 0;
    		display_black = FALSE;
    	}
    }

  /*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
  |                                                      KEYBOARD CONTROLS                                                  |
  ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/	 
  if(key_event_release(KEY_X))
		{
			ModMenu = !ModMenu;
		
		 
		
			if(!ModMenu)
			{
				ModEdit = FALSE; 		// close ModEdit too
				//save ();				// save function
				//combo_run(EXIT_SAVE);	// rumble, blink and display SAVED then display TITLE
				combo_run(RUMBLE_OFF);  // rumble and LED blink
				display_title = TRUE;   // display Title
			}
			
			if(ModMenu)
			{
				modName_idx = 0;        // start to the first adjustable value
				combo_run(RUMBLE_ON);	// rumble and LED blink
				display_new = TRUE;		// display mod name, profile, ON/OFF and value
			}
			}
	if((get_val(PS4_L1)) || (key_event_press(KEY_S)))
	{
	// Kill Switch	
		if(event_release(PS4_SHARE))
		{
			KillSwitch = !KillSwitch;
			
			if(KillSwitch)        
				combo_run(RUMBLE_OFF);	// rumble and LED blink
			else
				combo_run(RUMBLE_ON);	// rumble and LED blink
			
    		//display_black = FALSE;
			display_title = TRUE;
		}

  /*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
  |                                                       MOD MENU                                                        |
  ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/	 

	// toggle ModMenu ON/OFF
		if((key_event_release(KEY_S) && !KillSwitch) || (event_release(PS4_OPTIONS) && !KillSwitch))
		{
			ModMenu = !ModMenu;
			}
			if(key_event_press(KEY_X))
		{
			ModMenu = !ModMenu;
			}
			if(!ModMenu)
			{
				ModEdit = FALSE; 		// close ModEdit too
				//save ();				// save function
				//combo_run(EXIT_SAVE);	// rumble, blink and display SAVED then display TITLE
				combo_run(RUMBLE_OFF);  // rumble and LED blink
				display_title = TRUE;   // display Title
			}
			
			if(ModMenu)
			{
				modName_idx = 0;        // start to the first adjustable value
				combo_run(RUMBLE_ON);	// rumble and LED blink
				display_new = TRUE;		// display mod name, profile, ON/OFF and value
			}
		
		
		set_val(PS4_SHARE, 0);		    // block
		set_val(PS4_OPTIONS, 0);		// block
	} // L2 end

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 
if(!KillSwitch)
{
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 
// ModMenu
	if(ModMenu)
	{
            /*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
            |                                            MOD EDIT                                               |
            ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/	 

	// toggle ModEdit ON/OFF - only for mods who have adjustable value(s)
		if(modName_idx <= LAST_EDITABLE_STRING)	// if ANTIRECOIL (so modName_idx = 0) or AA or RAPIDFIRE or BURSTFIRE or StrafeShot is diplayed 
		{
			if(event_press(PS4_CROSS) && !ModEdit) // Turn ModEdit ON
			{
				valName_idx = AMOUNT_OF_VALNAME_IDX + 1; // always display first val names available when enter in edition mod
				ModEdit = TRUE;
				combo_run(RUMBLE_ON);
				display_new = TRUE;
			}
			
			if(event_press(PS4_CIRCLE) && ModEdit) // Turn ModEdit OFF
			{
				ModEdit = FALSE;
				combo_run(RUMBLE_OFF);
				display_new = TRUE;
			}
		}

            /*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
            |                                          EDIT VALUES                                              |
            ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/
            
	// ModEdit ON
		if(ModEdit)
		{
			if(get_val(PS4_L1)) // Edit value: hold L2 + UP (+1) or DOWN (-1) or RIGHT (+10) or LEFT (-10)
			{
			// Mods that can have different values depending the active Profile
			
    		  //val_I_want_to_edit[profile] = edit_val( corresponding valName_idx , val_I_want_to_edit[profile], abs(range min) , range max ); 	
				antirecoil_vertical[profile_idx]   = edit_val( 0 , antirecoil_vertical[profile_idx]  , 0  ,   99 , 1 , 10   ); // the first 0 define valName_idx so in this case, AR Start
				antirecoil_horizontal[profile_idx] = edit_val( 1 , antirecoil_horizontal[profile_idx], 99 ,   99 , 1 , 10   );
				antirecoil_start[profile_idx]      = edit_val( 2 , antirecoil_start[profile_idx]     , 0  ,   99 , 1 , 10   );
                antirecoil_end[profile_idx]        = edit_val( 3 , antirecoil_end[profile_idx]       , 0  ,   99 , 1 , 10   ); // the 2 last numbers are range min and range max
                antirecoil_time[profile_idx]       = edit_val( 4 , antirecoil_time[profile_idx]      , 0  ,   99 , 1 , 10   );
                horizontal_start[profile_idx]      = edit_val( 5 , horizontal_start[profile_idx]     , 99 ,   99 , 1 , 10   );
                horizontal_end[profile_idx]        = edit_val( 6 , horizontal_end[profile_idx]       , 99 ,   99 , 1 , 10   );
                horizontal_time[profile_idx]       = edit_val( 7 , horizontal_time[profile_idx]      , 99 ,   99 , 1 , 10   );
                rate_of_fire[profile_idx]          = edit_val( 8 , rate_of_fire[profile_idx]         ,  0 ,   25 , 1 , 10   ); 
                akimborf[profile_idx]              = edit_val( 9 , akimborf[profile_idx]            ,  0 ,   25 , 1 , 10   ); // 25 rounds/s max
				
			// Mods that have same value on every Profiles
			 //val_I_want_to_edit = edit_val( corresponding valName_idx , val_I_want_to_edit, range min , range max );
			    Sampling_Time                      = edit_val( 10 , Sampling_Time         , 0 , 10   , 1  , 10   );
                Aim_Boost                          = edit_val( 11 , Aim_Boost             , 0 , 10   , 1  , 10   ); 
                Aim_Correction                     = edit_val( 12 , Aim_Correction        , 0 , 10   , 1  , 10   ); 
                Aim_Perfection_Limit               = edit_val( 13 , Aim_Perfection_Limit  , 0 , 60   , 1  , 10   );
                ingamesens                         = edit_val( 14 , ingamesens            , 0 , 20   , 1  , 10   );
                RADIUS                             = edit_val( 15 , RADIUS                , 0 , 99   , 1  , 10   );
                STEPS                              = edit_val( 16 , STEPS                 , 0 , 99   , 1  , 10   ); 
                stickyaim_size                     = edit_val( 17 , stickyaim_size        , 0 , 50   , 1  , 10   );
                stickyaim_time                     = edit_val( 18 , stickyaim_time        , 0 , 990  , 1  , 10   );
                GEN_SENS                           = edit_val( 19 , GEN_SENS              , 0 , 327  , 1  , 10   );
                ADS_SENS                           = edit_val( 20 , ADS_SENS              , 0 , 327  , 1  , 10   ); 
                FIRE_SENS                          = edit_val( 21 , FIRE_SENS             , 0 , 327  , 1  , 10   ); 
                ADS_FIRE_SENS                      = edit_val( 22 , ADS_FIRE_SENS         , 0 , 327  , 1  , 10   );
                GRENADE_SENS                       = edit_val( 23 , GRENADE_SENS          , 0 , 327  , 1  , 10   );
                drop_speed                         = edit_val( 24 , drop_speed            , 0 , 9990 , 10 , 100  );
			
			}

            /*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
            |                                        VALUES AVAILABLE                                           |
            ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/

			else // NOT L2 (if not editing value)
			{
			// Navigate value name
				if(event_press(PS4_RIGHT))
				{
					valName_idx += 1;
					display_new = TRUE; // Display value name and value
				}
				if(event_press(PS4_LEFT))
				{
					valName_idx -= 1;
					display_new = TRUE;
				}
				
			// Adjustable values available for each of the mods (exemple: Anti-Recoil have 4 values per profile: 0 = antirecoil_start[<active profile>], 1 = antirecoil_end[], 2 = at_t, 3 = at_h  
			 // if(modName_idx == 0) <so if I display Anti-Recoil>  vals_available( 0 , 3  ); <vals_available are valName_idx 0, 1, 2 or 3>
				if(modName_idx == 0) vals_available( 0 , 1  );// Anti-Recoil		
				if(modName_idx == 1) vals_available( 2 , 7  );// Noozbar/Batts Progressive Antirecoil            				
				if(modName_idx == 2) vals_available( 8 , 8  );// Rapid Fire		
				if(modName_idx == 3) vals_available( 9 , 9  );// Itzsnack Akimbo Fire			
				if(modName_idx == 4) vals_available( 10 , 13  );//Sweet Evil Aim Assist
				if(modName_idx == 5) vals_available( 14 , 14 ); //Crescens Aim Corrections
				if(modName_idx == 6) vals_available( 15 , 16 ); //DoNoAtMe Polar Aim Assist
				if(modName_idx == 7) vals_available( 17 , 18 ); //Crescens Sticky Aim Assist
				if(modName_idx == 8) vals_available( 19 , 23 );  //Itzsnacks Custom Sensitivity
				if(modName_idx == 9) vals_available( 24 , 24 ); // Itzsnack Drop Shot
			} // NOT SQUARE (if not editing value) end
		} // ModEdit end

            /*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
            |                                            TOGGLES                                                |
            ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/

		else // if NOT ModEdit BUT if ModMenu
		{
		// Navigate mods name
			if(event_press(PS4_RIGHT))
			{
				modName_idx += 1;
				display_new = TRUE;
			}
			if(event_press(PS4_LEFT))
			{
				modName_idx -= 1;
				display_new = TRUE;
			}
			
		// Cycle mods name
			if(modName_idx > LAST_MODNAME_STRING) // max column for displaying mod name  
				modName_idx = 0;
			if(modName_idx < 0)
				modName_idx = LAST_MODNAME_STRING;
				
	
			
		// Toggles (UP to turn ON, DOWN to turn OFF)
    		// Mods that can have different ON/OFF status depending the active Profile
    		
		  //toggle_I_want_to_edit[profile]  = toggle( corresponding modName_idx, toggle_I_want_to_edit[profile] );
			toggle_antirecoil[profile_idx] = toggle( 0, toggle_antirecoil[profile_idx] );
			toggle_antirecoilh[profile_idx] = toggle( 1, toggle_antirecoilh[profile_idx] ); 
			toggle_rapidfire[profile_idx]  = toggle( 2, toggle_rapidfire[profile_idx]  );
			toggle_akimborf[profile_idx]   = toggle( 3, toggle_akimborf[profile_idx]   ); 
			sweetevil_on                   = toggle( 4, sweetevil_on                   );
            crescens_aim                   = toggle( 5, crescens_aim                   );
            polar_aim                      = toggle( 6, polar_aim                      );
            sticky_aim                     = toggle( 7, sticky_aim                     );
            snacks_sens                    = toggle( 8, snacks_sens                   );
            drop_shot                      = toggle( 9, drop_shot                      );
            toggle_holdbreath[profile_idx] = toggle( 10, toggle_holdbreath[profile_idx] );
          	// Mods that have same ON/OFF status on every Profiles
    		
		  //toggle_I_want_to_edit = toggle( corresponding modName_idx, toggle_I_want_to_edit );
			mp5comp_on  = toggle( 11 , mp5comp_on  );
			mp5ar_on     = toggle( 12 , mp5ar_on     );
			uziAnti_on = toggle( 13 , uziAnti_on );
			AutoSlideCancel_onoff = toggle( 14 , AutoSlideCancel_onoff );
		} // if NOT ModEdit BUT if ModMenu end
		
	// If ModMenu AND ModEdit
		if(event_press(PS4_PS))
			save ();
			
		//block_btn (); // block ALL btn (exept L2_R2_RX_RY_LX_LY to test antirecoil, rapidfire and burstfire against a wall without leaving ModEdit and ModMenu)
		block_all_inputs();
		
	} // ModMenu ON end


							/*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
							|                                              NOT MOD MENU AND NOT MOD EDIT                                             |
							◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — */	 
	if(!ModMenu)
	{
	
		if(mp5ar_on) // (6)
		{
			if(get_val(PS4_R1)) {

combo_run(MP5ar)

}
else if(combo_running (MP5ar)){ 

combo_stop(MP5ar)
}
		}


// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 
	
	// Hair Trigger
   	 	deadzone(PS4_L1,PS4_R1,99,99);
    	
 	 /*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
 	 |                                                     SWEET EVIL 5.3 AIM ASSIST                                         |
 	 ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/
     if (sweetevil_on) 
     {
          if (Joystick_calibration == FALSE)
            {
                RX_Axis_Joystick_calibrate = get_val(PS4_RX); 
                RY_Axis_Joystick_calibrate = get_val(PS4_RY); 
                Joystick_calibration = TRUE;     
            }
        X_Last_Value = X_Current_Value;
        Y_Last_Value = Y_Current_Value;
        X_Current_Value = get_lval(PS4_RX)- RX_Axis_Joystick_calibrate;
        Y_Current_Value = get_lval(PS4_RY)- RY_Axis_Joystick_calibrate;
            //--LT pulled 
        if(get_val(PS4_L1)) 
            {
            //--current & last value less than limit   
                if(abs(X_Current_Value) <= POS_Micro_MVT_Limit && abs(Y_Current_Value) <= POS_Micro_MVT_Limit) 
                {
                    //--both have a value        
                    //if(X_Last_Value && X_Current_Value) 
                        //{
                        //--difference between the 2 values less than 15         
                        if(abs(X_Last_Value - X_Current_Value) < 15) 
                            {
                                combo_stop(Aim_Assist_Perfection);
                                Sampling_Done = FALSE;
 
                                //--RT pulled more than 95%
                                if(get_val(PS4_R1) > 95) 
                                    {
                                        combo_stop(Fine_Tune_Aim);
                                        fine_pulse = 0;
                                        combo_run(spiroide_Aim_Assit);
                                    }
                                else
                                    {
                                        combo_stop(spiroide_Aim_Assit);
                                        spiroide_pulse = 0;
                                        combo_run(Fine_Tune_Aim);
                                    }    
                            }
                    //}
                }
                //--current and last greater than limit             
                else if(abs(X_Current_Value) <= POS_Aim_Limit && abs(Y_Current_Value) <= POS_Aim_Limit) 
                    {
                        combo_stop(Fine_Tune_Aim);
                        combo_stop(spiroide_Aim_Assit);
                        spiroide_pulse = 0;
                        fine_pulse = 0;
                        combo_run(Aim_Assist_Perfection);
                    }
        }
        else //--LT not pulled
            {
                combo_stop(Fine_Tune_Aim);
                combo_stop(spiroide_Aim_Assit);
                combo_stop(Aim_Assist_Perfection);
                spiroide_pulse = 0;
                fine_pulse = 0;
                Sampling_Done = FALSE;    
            }
            
            
 }

    /*-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0
    |                                           CRESCENS AIM CORRECTION                                                      |
    0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-*/
   
    if(crescens_aim)	
      {
      ads_grenade_sens=100-(ingamesens); ads_fire_sens=96-(ingamesens); 
      if (get_val (PS4_L1))
                    {
                                      if(get_val(PS4_R1) && get_val(PS4_L1))                              
                                              { 
                                              Sens = ads_fire_sens;                                              
                                              }
                                    if(!get_val(PS4_R1) && !get_val(PS4_L1) || get_val (PS4_R1) &&!get_val(PS4_L1)) 
                                              {
                                            Sens = 100; //--general sens & hip fire sens 
                                              }   
                                      if(!get_val(PS4_R1) && get_val(PS4_L1))
                                              {
                                            Sens = ads_grenade_sens;
                                              }
        if(Sens > 100) Sens = 100;  
        sensitivity(PS4_RX, NOT_USE, Sens);
        sensitivity(PS4_RY, NOT_USE, Sens);
    }
    }  //----------------------------end AIM_CORRECTIONS   
    
   
    /*-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0
    |                                          DoNotAtMe POLAR AIM ASSIST                                                    |
    0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-*/
   
    if(polar_aim){
    
      vm_tctrl(VM_INTERVAL); 
                         
      actual_X = get_val(X);   
      actual_Y = get_val(Y);           
      actual_Magnitude = isqrt(pow(actual_X, 2) + pow(actual_Y, 2));  
      max_Magnitude = (actual_Magnitude < 100);                      
                                                                  
      if(!(time++ % STEP_INTERVAL)){                                  
	         angle += STEPS;                                                 
      }                                                               
      angle = angle % 360;                                            
      sin_angle = Polar_Array[angle % 360];                           
      cos_angle = Polar_Array[(angle + 270) % 360];                  
      cos_angle = (cos_angle * RADIUS) / 100;                         
      sin_angle = (sin_angle * RADIUS) / 100;                          
                                                                         
      if((ACTIVE_WHEN_ADS && get_val(PS4_L1)) || (ACTIVE_WHEN_FIRING && get_val(PS4_R1))){ 
           if(actual_Magnitude <= RADIUS){                                                      
                sin_angle -= actual_Y;                                                              
                cos_angle -= actual_X;                                                                 
           }else {                                                                                       
                sin_angle = (sin_angle * (200 - ((abs(actual_Y) + actual_Magnitude) / 10) * 10) / 200) * max_Magnitude; 
                cos_angle = (cos_angle * (200 - ((abs(actual_X) + actual_Magnitude) / 10) * 10) / 200) * max_Magnitude; 
           }                                                  
           set_val(X, calculate(actual_X + cos_angle, -100, 100));
           set_val(Y, calculate(actual_Y + sin_angle, -100, 100)); 
      } 
  } 
    
  	/*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
  	|                                                 CRESCENS STICKY AIM                                                   |
  	◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/
     
    if(sticky_aim)
       {
    if(get_val(PS4_L1)  && !get_val(PS4_R1)) 
    combo_run(STICKY_AIM);
    else 
    combo_stop(STICKY_AIM); 
        } 
    
	
  	/*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
  	|                                                      OTHER MODS                                                       |
  	◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/

  if(toggle_holdbreath[profile_idx] == 1)
  {
  if(get_val(PS4_L1)) set_val(PS4_L3,100);
  }
  if(toggle_holdbreath[profile_idx] == 1)
  {
  if(get_val(PS4_LY) <-90 && get_val(PS4_L1) && get_ptime(PS4_L1) > 200) combo_stop(CH);
  }
  if(toggle_holdbreath[profile_idx] == 1) 
  {
  if(event_press(PS4_L1)) combo_run(CH);
  }
  if(toggle_holdbreath[profile_idx] == 1)
  {
  if(get_val(PS4_L1) && get_lval(PS4_L3)) set_val(PS4_L3,0); 
  }
  
        if(drop_shot)
         {
        if(get_val(PS4_R1)) combo_run(DS);
         }
   
        if(enemy_ping)
		{
		if(get_val(PS4_L1)&&double_click(PS4_UP)||event_press(PS4_R1))
	    combo_run(auto_ping);
		if(!get_val(PS4_L1))
		combo_stop(auto_ping);
		}
		
	    if(easy_plate)
		{
		if(get_val(PS4_TRIANGLE)&&get_ptime(PS4_TRIANGLE)>350)// change to double click if you want to put 3 plates after double pressing triangle
		combo_run(easy_plate);
		if(get_val(PS4_L1)>10)
		combo_stop(easy_plate);
		if(get_val(PS4_R1)>10)
		combo_stop(easy_plate);
		if(get_val(PS4_SQUARE))
		combo_stop(easy_plate);
		}
    if(snacks_sens)
    if(!get_val(PS4_L1) && !get_val(PS4_R1)) { 
    USE_SENS=GEN_SENS;}
    else if(get_val(PS4_L1) && !get_val(PS4_R1)) { 
    USE_SENS=ADS_SENS;}    
    else if(!get_val(PS4_L1) && get_val(PS4_R1)) { 
    USE_SENS=FIRE_SENS;}
    else if(get_val(PS4_L1) && get_val(PS4_R1)) { 
    USE_SENS=ADS_FIRE_SENS;}
    else if(get_val(PS4_R2)) { 
    USE_SENS=GRENADE_SENS;}
    sensitivity(PS4_RY,NOT_USE,USE_SENS);
    sensitivity(PS4_RX,NOT_USE,USE_SENS);		
	
	/* AutoRun press sensitive (Work better when in game option "Press to Sprint" is turned OFF)
    	 Push your stick to more than 60% to run automatically
    */	
		if(mp5comp_on){
		if(event_press(PS4_R1)) {
combo_run(CompMP5C)

}
else if(event_release (PS4_R1)){ 

combo_stop(CompMP5C)
}
	
		
	}
		
		if(AutoSlideCancel_onoff){
	if((get_val(PS4_LY) < -60) || (get_val(PS4_LY) > 60) || (get_val(PS4_LX) < -60) || (get_val(PS4_LX) > 60)) {
 
if(get_rumble(RUMBLE_A) == 87) { slide_enable = TRUE }
if(get_rumble(RUMBLE_A) == 0) { slide_enable = FALSE }

if(slide_enable) {
if(event_release (PS4_CIRCLE)){ combo_run(ASC) }
}
  }
	}
 
	// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜
		if(uziAnti_on){
		if(event_press(PS4_R1)) {
combo_run(uziAR)

}
else if(event_release (PS4_R1)){ 

combo_stop(uziAR)
}
	
		
	}
  	/*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
  	|                                                     SWITCH PROFILE                                                    |
  	◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/

	
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜
	} // ModMenu OFF end

							/*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
							|                                   FEATURES THAT WORK EVERYTIME (MOD MENU/EDIT OR NOT)                                 |
							◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/	 

  /*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
  |                                                    ANTI RECOIL (0)                                                    |
  ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/

// If Anti-Recoil is enable for the active profile
	if(toggle_antirecoil[profile_idx] == 1)
	{
		if(get_val(PS4_R1))
			combo_run(ANTIRECOIL);
		  else
			combo_stop(ANTIRECOIL);
	}

  /*-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0
  |                                    NOOZBAR PROGRESSIVE VERTICAL & HORIZONTAL ANTI-RECOIL                             |
  0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-*/
  
  if(toggle_antirecoilh[profile_idx] == 1)
	{
	// Antirecoil by Batts	
		// Vertical
    	if((VALUES[profile_idx][2] + antirecoil_start[profile_idx]) < (VALUES[profile_idx][3] + antirecoil_end[profile_idx]))
    	    i_val = 1; 
    	else
    	    i_val = -1;
        
    	i_pnt = ((VALUES[profile_idx][4] + antirecoil_time[profile_idx]) * 10) / (abs((VALUES[profile_idx][2] + antirecoil_start[profile_idx]) - (VALUES[profile_idx][3] + antirecoil_end[profile_idx]))); 
    	
    	// Horizontal		
    	if((VALUES[profile_idx][5] + horizontal_start[profile_idx]) < (VALUES[profile_idx][6] + horizontal_end[profile_idx]))
    	    i_val_h = 1; 
    	else
    	    i_val_h = -1;
        
    	i_pnt_h = ((VALUES[profile_idx][7] + horizontal_time[profile_idx]) * 10) / (abs((VALUES[profile_idx][5] + horizontal_start[profile_idx]) - (VALUES[profile_idx][6] + horizontal_end[profile_idx]))); 
    	
    	if(!get_val(PS4_R1)) 
   		{
   			// Vertical
   			ar_y = VALUES[profile_idx][2] + antirecoil_start[profile_idx];
   			i_cnt = 0;
   			i_num = 0;
   			
   			// Horizontal
   			ar_x = VALUES[profile_idx][5] + horizontal_start[profile_idx];
   			i_cnt_h = 0;
   			i_num_h = 0;
   		}   
    	
    	   if(get_val(PS4_R1))
    	   {
   		    // Vertical
   		    if(!p_complete())  
   		        ar_y = p_val();
   		    else
   		        ar_y = VALUES[profile_idx][3] + antirecoil_end[profile_idx];
            
			if(y_val() < 100)
    	   		set_val(PS4_RY,y_val()); 
    	   		
    	   	// Horizontal	
   		    if(!p_complete_x())  
   		        ar_x = p_val_x();
   		    else
   		        ar_x = VALUES[profile_idx][6] + horizontal_end[profile_idx];
            
			if(x_val() < 100)
    	   		set_val(PS4_RX,x_val()); 
   		}		
	
}

  /*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
  |                                                    RAPID FIRE (1)                                                     |
  ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/  
  
// If RapidFire is enable for the active profile
	if(toggle_rapidfire[profile_idx] == 1)
	{
	// Rate of Fire Calculation
    	hold_time = 500 / (VALUES[profile_idx][8] + rate_of_fire[profile_idx]); 
   		rest_time = hold_time - 20;
    	if(rest_time < 0) rest_time = 0;
    
    // Run combo
    	if(get_val(PS4_R1))
    		combo_run(RAPIDFIRE);
    	else
    		combo_stop(RAPIDFIRE);
    		
    	led_on = 150;
    	led_off = 300;
    	combo_run(BLINK);
	}
  /*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
  |                                               ITZSNACK AKIMBO RAPID FIRE                                              |
  ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/ 
   if(toggle_akimborf[profile_idx] == 1) 
   { 	
    if(get_val(PS4_R1))
    combo_run(ARF);
    else 
    combo_stop(ARF);
   
        led_on = 150;
    	led_off = 300;
    	combo_run(BLINK);   
       
   }

		
  /*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
  |                                                    REFRESH DISPLAY                                                    |
  ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/	
	if(display_new) 
	{
	// Clear OLED screen	
		cls_oled(0);
    	count_black = 0;// reset screen saver counter
		
		if(ModEdit)
		{
	    // Display Value Name and value
    		// Mods that can have different values depending the active Profile
    		
		  //display_edit( corresponding valName_idx , center_x(sizeof(corresponding_string_to_display) - 1, MEDIUM) , corresponding_string_to_display[0] , val_I_want_to_be_displayed[profile] );
			display_edit( 0 , center_x(sizeof(ANTIRECOIL_VERTICAL) - 1, OLED_FONT_MEDIUM_WIDTH)   , ANTIRECOIL_VERTICAL[0]   , antirecoil_vertical[profile_idx]   );
			display_edit( 1 , center_x(sizeof(ANTIRECOIL_HORIZONTAL) - 1, OLED_FONT_MEDIUM_WIDTH) , ANTIRECOIL_HORIZONTAL[0] , antirecoil_horizontal[profile_idx] );
			display_edit( 2  , center_x(sizeof(ANTIRECOIL_START)  - 1, OLED_FONT_MEDIUM_WIDTH)  , ANTIRECOIL_START[0]  , antirecoil_start[profile_idx] );
            display_edit( 3  , center_x(sizeof(ANTIRECOIL_END)    - 1, OLED_FONT_MEDIUM_WIDTH)  , ANTIRECOIL_END[0]    , antirecoil_end[profile_idx]   );
            display_edit( 4  , center_x(sizeof(ANTIRECOIL_TIME)   - 1, OLED_FONT_MEDIUM_WIDTH)  , ANTIRECOIL_TIME[0]   , antirecoil_time[profile_idx]  );
            display_edit( 5  , center_x(sizeof(HORIZONTAL_START)  - 1, OLED_FONT_MEDIUM_WIDTH)  , HORIZONTAL_START[0]   , horizontal_start[profile_idx] );
            display_edit( 6  , center_x(sizeof(HORIZONTAL_END)    - 1, OLED_FONT_MEDIUM_WIDTH)  , HORIZONTAL_END[0]    , horizontal_end[profile_idx]   );
            display_edit( 7  , center_x(sizeof(HORIZONTAL_TIME)   - 1, OLED_FONT_MEDIUM_WIDTH)  , HORIZONTAL_TIME[0]   , horizontal_time[profile_idx]  );
            display_edit( 8 , center_x(sizeof(RATE_OF_FIRE)      - 1, OLED_FONT_MEDIUM_WIDTH)  , RATE_OF_FIRE[0]      , rate_of_fire[profile_idx]     );
            display_edit( 9 , center_x(sizeof(AKIMBOFIRE1)       - 1, OLED_FONT_MEDIUM_WIDTH)  , AKIMBOFIRE1[0]       , akimborf[profile_idx]         );
            display_edit( 10 , center_x(sizeof(SAMPLINGTIME)      - 1, OLED_FONT_MEDIUM_WIDTH)  , SAMPLINGTIME[0]      , Sampling_Time                 );
            display_edit( 11 , center_x(sizeof(AIMBOOST)          - 1, OLED_FONT_MEDIUM_WIDTH)  , AIMBOOST[0]          , Aim_Boost                     );
            display_edit( 12 , center_x(sizeof(AIMCORRECT)        - 1, OLED_FONT_MEDIUM_WIDTH)  , AIMCORRECT[0]        , Aim_Correction                );
            display_edit( 13 , center_x(sizeof(AIMPERFECT)        - 1, OLED_FONT_MEDIUM_WIDTH)  , AIMPERFECT[0]        , Aim_Perfection_Limit          );
            display_edit( 14 , center_x(sizeof(INGAMESENS)        - 1, OLED_FONT_MEDIUM_WIDTH)  , INGAMESENS[0]        , ingamesens                    );
            display_edit( 15 , center_x(sizeof(POLAR_RADIUS)      - 1,OLED_FONT_MEDIUM_WIDTH)   , POLAR_RADIUS[0]      , RADIUS                        );
            display_edit( 16 , center_x(sizeof(POLAR_STEPS)       - 1, OLED_FONT_MEDIUM_WIDTH)  , POLAR_STEPS[0]       , STEPS                         );
            display_edit( 17 , center_x(sizeof(STICKYAIM_SIZE)    - 1, OLED_FONT_MEDIUM_WIDTH)  , STICKYAIM_SIZE[0]    , stickyaim_size                );
            display_edit( 18 , center_x(sizeof(STICKYAIM_TIME)    - 1, OLED_FONT_MEDIUM_WIDTH)  , STICKYAIM_TIME[0]    , stickyaim_time                );
            display_edit( 19 , center_x(sizeof(GENSENS)           - 1, OLED_FONT_MEDIUM_WIDTH)  , GENSENS[0]           , GEN_SENS                      ); 
            display_edit( 20 , center_x(sizeof(ADSSENS)           - 1, OLED_FONT_MEDIUM_WIDTH)  , ADSSENS[0]           , ADS_SENS                      ); 
            display_edit( 21 , center_x(sizeof(FIRESENS)          - 1, OLED_FONT_MEDIUM_WIDTH)  , FIRESENS[0]          , FIRE_SENS                     ); 
            display_edit( 22 , center_x(sizeof(ADSFIRESENS)       - 1, OLED_FONT_MEDIUM_WIDTH)  , ADSFIRESENS[0]       , ADS_FIRE_SENS                 ); 
            display_edit( 23 , center_x(sizeof(GRENADESENS)       - 1, OLED_FONT_MEDIUM_WIDTH)  , GRENADESENS[0]       , GRENADE_SENS                  );
            display_edit( 24 , center_x(sizeof(DROPSHOTSPEED)     - 1, OLED_FONT_MEDIUM_WIDTH)  , DROPSHOTSPEED[0]     , drop_speed                    );
		
		}
		else
		{
	    // Display Mod Name and ON/OFF
    		// Mods that can have different ON/OFF status depending the active Profile
    		
		  //display_mod( corresponding modName_idx , center_x(sizeof(corresponding_string_to_display) - 1, MEDIUM) , corresponding_string_to_display[0] , toggle_I_want_to_be_displayed[profile]);
			display_mod( 0 ,  center_x(sizeof(ANTIRECOIL) - 1, OLED_FONT_MEDIUM_WIDTH) , ANTIRECOIL[0] , toggle_antirecoil[profile_idx]);
			display_mod( 1 ,  center_x(sizeof(ANTIRECOILH) - 1, OLED_FONT_MEDIUM_WIDTH)  , ANTIRECOILH[0]   , toggle_antirecoilh[profile_idx]);
            display_mod( 2 ,  center_x(sizeof(RAPIDFIRE)   - 1, OLED_FONT_MEDIUM_WIDTH)  , RAPIDFIRE[0]     , toggle_rapidfire[profile_idx]);
            display_mod( 3 ,  center_x(sizeof(AKIMBOFIRE)  - 1, OLED_FONT_MEDIUM_WIDTH)  , AKIMBOFIRE[0]    , toggle_akimborf[profile_idx]);
            display_mod( 4 ,  center_x(sizeof(SWEETEVIL)   - 1, OLED_FONT_MEDIUM_WIDTH)  , SWEETEVIL[0]     , sweetevil_on );
            display_mod( 5 ,  center_x(sizeof(CRESCENS)    - 1, OLED_FONT_MEDIUM_WIDTH)  , CRESCENS[0]      , crescens_aim );
            display_mod( 6 ,  center_x(sizeof(POLARAIM)    - 1, OLED_FONT_MEDIUM_WIDTH)  , POLARAIM[0]      , polar_aim );
            display_mod( 7 ,  center_x(sizeof(STICKYAIM)   - 1, OLED_FONT_MEDIUM_WIDTH)  , STICKYAIM[0]     , sticky_aim );
            display_mod( 8 ,  center_x(sizeof(SNACKSENS)    - 1, OLED_FONT_MEDIUM_WIDTH)  , SNACKSENS[0]      , snacks_sens );
            display_mod( 9 ,  center_x(sizeof(DROPSHOT)    - 1, OLED_FONT_MEDIUM_WIDTH)  , DROPSHOT[0]      , drop_shot );
            display_mod( 10 , center_x(sizeof(HOLD_BREATH) - 1, OLED_FONT_MEDIUM_WIDTH)  , HOLD_BREATH[0]   , toggle_holdbreath[profile_idx]);
         
			// Mods that have same ON/OFF status on every Profile
			display_mod( 11 ,  center_x(sizeof(M4ANTI) - 1, OLED_FONT_MEDIUM_WIDTH) , M4ANTI[0] , mp5comp_on);
			display_mod( 12 ,  center_x(sizeof(MP5ANTI) - 1, OLED_FONT_MEDIUM_WIDTH)    , MP5ANTI[0]    , mp5ar_on);
			display_mod( 13 ,  center_x(sizeof(UZIANTI) - 1, OLED_FONT_MEDIUM_WIDTH), UZIANTI[0], uziAnti_on);
			display_mod( 14 ,  center_x(sizeof(AUTOSLIDECANCEL) - 1, OLED_FONT_MEDIUM_WIDTH), AUTOSLIDECANCEL[0], AutoSlideCancel_onoff);
		}
		
	// Display Profile only on mods that may have a different value depending on the Profile
		if(modName_idx < AMOUNT_OF_MULTI_TOGGLE)  // idx from 0 to 4 are mods that can have different values depending the active Profile
		{
			if(profile_idx == 0) // profile_idx = profile_idx = Profile
    			//printf(center_x(sizeof(TITLE_2) - 1, OLED_FONT_SMALL_WIDTH),23,OLED_FONT_SMALL,OLED_WHITE,TITLE_2[0]); // print Profile 1
    			line_oled(0, 26, 127, 26, 6, 1); // print a line to the left to say profile 1
    		
		}
		else // Mods that work on every profiles print the 3 lines (disable this if you prefer display the text Profile X
    	{
    	line_oled(0, 26, 127, 26, 6, 1);
    	}
    	
		display_black = TRUE;
        display_new = FALSE;
    } // display_new end
    
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 
} // NOT KillSwitch end

	led(profile_idx);

} // main end
 
  /*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
  |                                                     COMBO SECTION                                                     |
  ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/	

combo Aim_Assist_Perfection 
       {
        // Save the first joystick position 
        X_Last_Value = X_Current_Value
        Y_Last_Value = Y_Current_Value
 
        // Sampling frequency 
        wait(Sampling_Time);
 
        // Save the second joystick position 
        X_Current_Value = get_lval(PS4_RX)- RX_Axis_Joystick_calibrate;
        Y_Current_Value = get_lval(PS4_RY)- RY_Axis_Joystick_calibrate; 
 
     if (Sampling_Done == TRUE )
        {
            //Applying BOOST
            //Aim_Perfection(Last_Value, Current_Value, Boost, Correction, X_AXIS, Y_AXIS ) 
            Aim_Perfection(X_Last_Value, X_Current_Value, 1, 0, 1, 0 ); 
            Aim_Perfection(Y_Last_Value, Y_Current_Value, 1, 0, 0, 1 ); 
        }
 
        X_Last_Value = X_Current_Value;
        Y_Last_Value = Y_Current_Value;
 
        // Sampling frequency 
        wait(Sampling_Time);
 
        // Save the second joystick position 
        X_Current_Value = get_lval(PS4_RX)- RX_Axis_Joystick_calibrate;
        Y_Current_Value = get_lval(PS4_RY)- RX_Axis_Joystick_calibrate; 
 
   if (Sampling_Done == TRUE )
        {
            //Applying CORRECTION
            //Aim_Perfection(Last_Value, Current_Value, Boost, Correction, X_AXIS, Y_AXIS )
            Aim_Perfection(X_Last_Value, X_Current_Value, 0, 1, 1, 0 ); 
            Aim_Perfection(Y_Last_Value, Y_Current_Value, 0, 1, 0, 1 ); 
        }
 
        Sampling_Done = TRUE; 
        wait(Sampling_Time);
    }
    
    combo MP5ar {
	offset(PS4_RX, -7);
	offset(PS4_RY, 25);
	offset(PS4_LX, 3);
	wait(80);
	offset(PS4_RX, -7);
	offset(PS4_RY, 25);
	offset(PS4_LX, 3);
	wait(230);
	offset(PS4_RX, -6);
	offset(PS4_RY, 16);
	offset(PS4_LX, 3);
	wait(310);
	offset(PS4_RX, -3);
	offset(PS4_RY, 15);
	offset(PS4_LX, 3);
	wait(990);
	offset(PS4_RX, -4);
	offset(PS4_RY, 17);
	offset(PS4_LX, 3);
	wait(690);
	offset(PS4_RX, -1);
	offset(PS4_RY, 0);
	offset(PS4_LX, 3);
	wait(680);
	offset(PS4_RX, -1);
	offset(PS4_LX, 3);
	wait(320);
	offset(PS4_RX, -1);
	offset(PS4_LX, 1);
	wait(10);
	offset(PS4_RX, -1);
	offset(PS4_LX, 3);
	wait(720);
	offset(PS4_RX, 0);
	offset(PS4_LX, 0);
}
 
combo Fine_Tune_Aim {
 
    set_val(PS4_RX,(15 - fine_pulse));//right
    set_val(PS4_LX,(-15 + fine_pulse));//move left
    wait(Sampling_Time);
 
    wait(Sampling_Time);
    wait(Sampling_Time);
 
    set_val(PS4_RX,(15 - fine_pulse));//right+down
    set_val(PS4_RY,(10 - fine_pulse));
    set_val(PS4_LX,(-5 + fine_pulse));//move left
    wait(Sampling_Time);
 
    wait(Sampling_Time);
    wait(Sampling_Time);
 
 
    set_val(PS4_RY,(10 - fine_pulse));// down
    wait(Sampling_Time);
 
    wait(Sampling_Time);
    wait(Sampling_Time);
    wait(Sampling_Time);
 
    set_val(PS4_RX,(-15 + fine_pulse));//left+down
    set_val(PS4_RY,(10 - fine_pulse));
    set_val(PS4_LX,(5 - fine_pulse))//move 	right
    wait(Sampling_Time);
 
    wait(Sampling_Time)
    wait(Sampling_Time)
 
    set_val(PS4_RX,(-15 + fine_pulse));// left
    set_val(PS4_LX,(15 - fine_pulse))//move 	right
    wait(Sampling_Time);
 
    wait(Sampling_Time);
    wait(Sampling_Time);
 
    set_val(PS4_RX,(-15 + fine_pulse)); //left + up
    set_val(PS4_RY,(-10 + fine_pulse));
    set_val(PS4_LX,(5 - fine_pulse))//move 	right
    wait(Sampling_Time);
 
    wait(Sampling_Time);
    wait(Sampling_Time);
 
    set_val(PS4_RY,(-10 + fine_pulse)); //up
    wait(Sampling_Time);
 
    wait(Sampling_Time);
    wait(Sampling_Time);
    wait(Sampling_Time);
 
    set_val(PS4_RX,(15 - fine_pulse));//right+up
    set_val(PS4_RY,(-10 + fine_pulse));
    set_val(PS4_LX,(-5 + fine_pulse))//move 	left
    wait(Sampling_Time);
 
    wait(Sampling_Time);
 
    fine_pulse = fine_pulse + 2;
 
 
    if ( fine_pulse >10)
       {
            fine_pulse = 0;   
        }
   }
 
combo spiroide_Aim_Assit {
 
    set_val(PS4_RX,(4 + spiroide_pulse));//right
    set_val(PS4_LX,(-15+ spiroide_pulse));//move left
    wait(Sampling_Time);
 
    wait(Sampling_Time);
 
 
    set_val(PS4_RY,(5 + spiroide_pulse));// down
    wait(Sampling_Time);
 
    wait(Sampling_Time);
    wait(Sampling_Time);
    wait(Sampling_Time);
 
    set_val(PS4_RX,(-4 - spiroide_pulse));//left
    set_val(PS4_LX,15 - spiroide_pulse );//move right
    wait(Sampling_Time);
 
    wait(Sampling_Time)
 
    set_val(PS4_RY,(5 + spiroide_pulse));// down
    wait(Sampling_Time);
 
    wait(Sampling_Time);
    wait(Sampling_Time);
    wait(Sampling_Time);
 
 
    spiroide_pulse = spiroide_pulse + 2;
 
 
    if ( spiroide_pulse >10)
       {
            spiroide_pulse = 0;   
        }
   } 
   
combo CH {
	set_val(PS4_L3,0);
	wait(60);
	set_val(PS4_L3,100);
	wait(110);
	set_val(PS4_L3,0);
	wait(110);}

combo auto_ping
	{set_val(PS4_UP,100);
	wait(20)
	set_val(PS4_UP,0);
	wait(20)
	set_val(PS4_UP,100);
	wait(20)
	set_val(PS4_UP,0);
	}
combo easy_plate
	{set_val(PS4_TRIANGLE,100);
	wait(6000)}//time triangle is held for adjust higher or lower 500 if you only get 2 plates or cant switch weapons after replating

combo DS {
    set_val(PS4_CIRCLE,100);
    wait(40);
    set_val(PS4_CIRCLE,0);
    wait(drop_speed);} 

combo STICKY_AIM {
    set_val(PS4_RY,xy_val(PS4_RY, stickyaim_size));
    wait(stickyaim_time);
    set_val(PS4_RX,xy_val(PS4_RX, stickyaim_size));
    set_val(PS4_LX,xy_val(PS4_LX, stickyaim_size));
    wait(stickyaim_time);
    set_val(PS4_RY,xy_val(PS4_RY, stickyaim_size * -1));
    wait(stickyaim_time);
    set_val(PS4_RX,xy_val(PS4_RX, stickyaim_size * -1));
    set_val(PS4_LX,xy_val(PS4_LX, stickyaim_size * -1));
    wait(stickyaim_time);
    }

combo ARF {
    set_val(PS4_R1,100);
    set_val(PS4_L1,100);
    wait(40);
    set_val(PS4_R1,0);
    set_val(PS4_L1,0);
    wait(akimborf);}

combo RUMBLE_ON {						// 2 high rumbles + green blink 2 times
	set_ledx(2, 2);
	set_rumble(RUMBLE_B, 50);
	wait(150);
	reset_rumble();
	wait(100);
	set_rumble(RUMBLE_B, 50);
	wait(150);
	reset_rumble();
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

combo RUMBLE_OFF {						// 1 high rumble + red blink 1 time
	set_ledx(1, 1);
	set_rumble(RUMBLE_A, 50);
	wait(300);
	reset_rumble();
	wait(400);
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

combo SAVE { 
	cls_oled(0);						// clear OLED screen 
	printf(center_x(sizeof(SAVE) - 1,OLED_FONT_LARGE_WIDTH),center_y(OLED_FONT_LARGE_HEIGHT),OLED_FONT_LARGE,OLED_WHITE,SAVE[0]); 	// display SAVED... centered in X Y 
	wait(10)
	call(RUMBLE_ON);					// 2 high rumbles + green blink 2 times								
	wait(150);
	call(RUMBLE_ON);					// 2 high rumbles + green blink 2 times	
	wait(1000);
	display_new = TRUE;				   // display mods
}

combo ANTIRECOIL {
// Vertical
    AntirecoilVertical = get_val(PS4_RY) + (VALUES[profile_idx][0] + antirecoil_vertical[profile_idx]);  
    if(AntirecoilVertical > 100) AntirecoilVertical = 100;
    if(abs(get_val(PS4_RY)) < abs(VALUES[profile_idx][0] + antirecoil_vertical[profile_idx]) + 5)
    set_val(PS4_RY, (AntirecoilVertical * invert));
// Horizontal
    AntirecoilHorizontal = get_val(PS4_RX) + (VALUES[profile_idx][1] + antirecoil_horizontal[profile_idx]);
    if(AntirecoilHorizontal > 100) AntirecoilHorizontal = 100;
    if(abs(get_val(PS4_RX)) < abs(VALUES[profile_idx][1] + antirecoil_horizontal[profile_idx]) + 5)
    set_val(PS4_RX, AntirecoilHorizontal);
}
 
combo RAPIDFIRE { 
    wait(hold_time);
    set_val(PS4_R1, 0);
    wait(rest_time);
    }


combo BLINK {
	led(profile_idx);
    wait(led_on);
    led(7);
    wait(led_off);
    }
    
    combo ASC { // Professional Slide Cancel.
 wait(14); // If this becomes an issue, change it to 12 or 15. Worked fine here.
    set_val(PS4_CIRCLE, 100);
    wait(14); // If this becomes and issue, change to anything between 11-20.
    set_val(PS4_CIRCLE, 100);
    set_val(PS4_CROSS, 100);
    wait(12);
    set_val(PS4_CIRCLE, 0);
    set_val(PS4_CROSS, 100);
    wait(12);
    set_val(PS4_CROSS, 0);
}

  /*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
  |                                                       FUNCTIONS                                                       |
  ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/	
function Aim_Perfection(Last_Value, Current_Value, Boost, Correction, X_AXIS, Y_AXIS ) 
    { 
 
 
       if(abs(Last_Value - Current_Value) < Aim_Perfection_Limit) 
            {
                //--moving right
                if(Last_Value < Current_Value)
                    {           
                        if (Boost)
                            { 
                                if (X_AXIS)
                                    set_val(PS4_RX, (Current_Value + Aim_Boost)); 
 
                                if (Y_AXIS)
                                        set_val(PS4_RY, (Current_Value + Aim_Boost));
                            }
 
 
                        else if(Correction)
                            {
                                if (X_AXIS)
                                    set_val(PS4_RX, (Current_Value - Aim_Correction)); 
 
                                if (Y_AXIS)
                                set_val(PS4_RY, (Current_Value - Aim_Correction));            
                            }
                    }
                else //--moving left
                    {
 
                        if (Boost)
                            { 
                                if (X_AXIS)
                                    set_val(PS4_RX, (Current_Value - Aim_Boost)); 
 
                                if (Y_AXIS)
                                        set_val(PS4_RY, (Current_Value - Aim_Boost));
                            }
 
 
                        else if(Correction)
                            {
                                if (X_AXIS)
                                    set_val(PS4_RX, (Current_Value + Aim_Correction)); 
 
                                if (Y_AXIS)
                                set_val(PS4_RY, (Current_Value + Aim_Correction));            
                            }
                    }
            }
    } 

function double_click(button) {        
    if (double__tap[button] >= 0) {                    
        double__tap[button] += get_rtime(); 
        if (double__tap[button] > 450)
            double__tap[button] = -1;                                                                                       
    }           
    if (event_release(button) && get_ptime(button) <= 200) { 
        if (double__tap[button] < 0) {                    
            double__tap[button] = 0;                        
        } else {             
            double__tap[button] = -1;                       
            return 1;                                   
        }                                                     
    }                                                  
    return 0;
    }
    
function calculate(int v, int lo, int hi) { 
  if(v < lo) return lo;               
  if(v > hi) return hi;        
  return v;     
}     
function xy_val(f_axis,f_val) {
    if(abs(get_val(f_axis)) < stickyaim_size + 1) 
        return f_val;
    return get_val(f_axis); 
}


function p_complete() { // Antirecoil
 
    i_cnt++;
    if(i_cnt > (VALUES[profile_idx][4] + antirecoil_time[profile_idx]) * 10) 
    {
        i_cnt = (VALUES[profile_idx][4] + antirecoil_time[profile_idx]) * 10;
        return 1;
    }    
    return 0;
}  
 
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 
 
function p_val() { // Antirecoil
 
    i_num++;
    if(i_num == i_pnt) {
    
        i_num = 0;
        ar_y += i_val;
    }
    return ar_y;
}  
 
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 
 
function y_val() { // Antirecoil
 
    v = get_val(10);
 
    if(abs(v) < 10)
        v = 0;
 
    if(abs(v) > ar_y + 5)
        return v;
 
    return v + (ar_y * invert);           
}
 
 // Horizontal
function p_complete_x() { 
    i_cnt_h++;
    if (i_cnt_h > (VALUES[profile_idx][7] + horizontal_time[profile_idx]) * 10) {                                                               
    	//--avoid stack overflow
        i_cnt_h = (VALUES[profile_idx][7] + horizontal_time[profile_idx]) * 10;                                                                                         
        //--progression complete
        return 1;
       }
       return 0;
  }     
    //--progression not complete 
     
function p_val_x() {
    i_num_h++;
    if(i_num_h == i_pnt_h) {
        //--reset counter
    	i_num_h = 0;
    	//--adjust ar_x 
    	ar_x += i_val_h;
    }
    return ar_x;
} 
function x_val() {
	v_x = get_val(PS4_RX);
	if(abs(v_x) < 10)
		v_x = 0;
	if(abs(v_x) > abs(ar_x + 5))
		return v_x;
	return v_x + ar_x;   	    
}

function vals_available(f_min, f_max) { // Define adjustable values available for each of the mods

	if(valName_idx < f_min)
		valName_idx = f_max;
	if(valName_idx > f_max)
		valName_idx = f_min;
		
// Match the # of value names index with the right column in VALUES array
	val_col_idx = valName_idx;	
}

combo CompMP5C {
	 
	
	
	offset(PS4_RX, -9);
	offset(PS4_RY, 32);
	wait(310);
	offset(PS4_RX, -7);
	offset(PS4_RY, 20);
	wait(310);
	offset(PS4_RX, -4);
	offset(PS4_RY, 20);
	wait(990);
	offset(PS4_RX, -5);
	offset(PS4_RY, 23);
	wait(690);
	offset(PS4_RX, 0);
	offset(PS4_RY, 0);
	wait(300);

}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function edit_val(f_idx, f_val, f_min, f_max, f_inc1, f_inc2) {  // antirecoil_start[profile_idx] = edit_val( 0 , antirecoil_start[profile_idx], 99  , 99  )
					
	if(valName_idx == f_idx)
	{
    // +1 or -1															 // We can add function variable for increase/decrease to define if we increase/decrease by 1, 10, 100 ...
    	f_val    = value_change( f_val ,PS4_LEFT , inv(f_inc1), f_min, f_max ); // inv(f_inc1)
    	f_val    = value_change( f_val ,PS4_RIGHT, f_inc1     , f_min, f_max ); // f_inc1
   	 // +10 or -10
   	   	f_val    = value_change( f_val ,PS4_DOWN , inv(f_inc2), f_min, f_max ); // inv(f_inc2)
       	f_val    = value_change( f_val ,PS4_UP   , f_inc2     , f_min, f_max ); // f_inc2

	// We can also add (f_ref)
	// Value for your features  // antirecoil_start_final = VALUES[profile_idx][val_col_idx] +  antirecoil_start[profile_idx] ;
        //f_ref = VALUES[profile_idx][val_col_idx] + f_val ;	
	}
	// Block Rate of Fire to 1 minimum (if 0 combo goes crazy lol)
	if(rate_of_fire[profile_idx] < 0)
		rate_of_fire[profile_idx] = 0;

	//return f_ref;

	return f_val;
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

/*function speed_toggle(f_hold, f_press, f_val, f_string) {  // toggle_aimassist[profile_idx] = speed_toggle(PS4_R3, PS4_UP, toggle_aimassist[profile_idx], #cons_string for this toggle);
	
	if(get_val(f_hold))
	{
		if(get_val(f_press) && get_ptime(f_press) == 300) // Hold second button 300ms or more
		{
			modName_idx = f_string;
			
			if(f_val == 0)
			{
				if(f_string == 1) // If RapidFire is enable, 
					//toggle_burstfire[profile_idx] = 0; // disable BurstFire
				//else if(f_string == 2) // If BurstFire is enable, 
					//toggle_rapidfire[profile_idx] = 0; // disable RapidFire
					
				f_val = 1;
				combo_run(RUMBLE_ON);
			}
			else
			{
				f_val = 0;
				combo_run(RUMBLE_OFF);
			}
			display_new = TRUE;
		} 
	set_val(f_press, 0)
	}
		
	return f_val;
}
*/
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function toggle(f_idx, f_val) { // toggle_antirecoil[profile_idx] = toggle(1, PS4_UP, toggle_antirecoil[profile_idx]);
	
	if(event_press(PS4_UP))
	{
		if(modName_idx == f_idx)
		{
			if(f_idx == 1) // If RapidFire is enable, 
				//toggle_burstfire[profile_idx] = 0; // disable BurstFire
			//else if(f_idx == 2) // If BurstFire is enable, 
				toggle_rapidfire[profile_idx] = 0; // disable RapidFire
				
			f_val = 1;
			combo_run(RUMBLE_ON);
		}
		
		display_new = TRUE;
	}
			
	if(event_press(PS4_DOWN))
	{
		if(modName_idx == f_idx)
		{
			f_val = 0;
			combo_run(RUMBLE_OFF);
		}		
		display_new = TRUE;
	}
	return f_val;
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function display_edit(f_idx, f_string, f_print, f_val) { // display_edit(0, center_x(sizeof(ANTIRECOIL_START) - 1, OLED_FONT_MEDIUM_WIDTH) , ANTIRECOIL_START[0], antirecoil_start[profile_idx]);

    	if(valName_idx == f_idx)
    	{
		// Display value name and value
    		printf(f_string, 0, OLED_FONT_MEDIUM, OLED_WHITE, f_print);
    		
    	// Display AntiRecoil Time value x 100 so 1,000 (displayed) = 1 second - script value is 10
    		if(f_idx == 4 || f_idx == 7) 
    			number_to_string((VALUES[profile_idx][val_col_idx] + f_val) * 100, find_digits((VALUES[profile_idx][val_col_idx] + f_val) * 100));
    	
    	// Display all editable values in VALUES array
    		else if(f_idx <= LAST_EDITABLE_COLUMN) 
    			number_to_string(VALUES[profile_idx][val_col_idx] + f_val, find_digits(VALUES[profile_idx][val_col_idx] + f_val));
    	
    	// Display editable values that are not in the array (burstfire_hold for exemple)
    		else 
    			number_to_string(f_val, find_digits(f_val));
    	}
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function display_mod(f_idx, f_string, f_print, f_toggle) { // display_mod(1, center_x(sizeof(ANTIRECOIL) - 1, MEDIUM) , ANTIRECOIL[0], toggle_antirecoil[profile_idx]);
    	if(modName_idx == f_idx)
    	{
		// Display MOD_NAME
    		printf(f_string, 0, OLED_FONT_MEDIUM, OLED_WHITE, f_print);
        	
    	// Display ON OFF
    		if(f_toggle == 1)
    			printf(center_x(sizeof(ON) - 1, OLED_FONT_MEDIUM_WIDTH),37,OLED_FONT_MEDIUM,OLED_WHITE,ON[0]);
    		else
    			printf(center_x(sizeof(OFF) - 1, OLED_FONT_MEDIUM_WIDTH),37,OLED_FONT_MEDIUM,OLED_WHITE,OFF[0]);
    	}
}

combo uziAR {
		offset(PS4_RX, -4);
	offset(PS4_RY, 24);
	wait(80);
	offset(PS4_RX, -4);
	offset(PS4_RY, 24);
	wait(350);
	offset(PS4_RX, -3);
	offset(PS4_RY, 20);
	wait(310);
	offset(PS4_RX, -3);
	offset(PS4_RY, -17);
	wait(220);
	offset(PS4_RX, -2);
	offset(PS4_RY, 12);
	wait(2260);
	offset(PS4_RX, -1);
	offset(PS4_RY, 0);
	wait(400);
	offset(PS4_RX, -1);
	wait(60);
	offset(PS4_RX, -1);
}

//////////////////////////////////////////////////////////////////////////
//clamp2
//////////////////////////////////////////////////////////////////////////
function clamp2(v, lo, hi) 
{
    if(v < lo) return lo;
    if(v > hi) return hi;
    return v;
}

//////////////////////////////////////////////////////////////////////////
//Offset
//////////////////////////////////////////////////////////////////////////
function offset(int axis, int offset_val) {
	set_val(axis, clamp2(offset_val * (100 - abs(get_val(axis))) / 100 + get_val(axis), -100, 100));
return 
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function value_change(f_val,f_btn,f_inc, f_rng_min, f_rng_max) { 

    if(press_hold(f_btn)) 
    {
        f_val += f_inc;
        
    // Values that are not in the array (aimassist_time for exemple)
		if(valName_idx > LAST_EDITABLE_COLUMN)
		{
    	// Substract    
        	if(f_val < inv(f_rng_min)) 
        		f_val = inv(f_rng_min); 
   		// Add   
       		if(f_val > f_rng_max) 
        		f_val = f_rng_max;
		}
		
    // Values that are in the array 
		else
		{
    // Substract    
        if((f_val + VALUES[profile_idx][val_col_idx]) < inv(f_rng_min)) 
        	f_val = inv(f_rng_min + VALUES[profile_idx][val_col_idx]); 
    // Add   
        if((f_val + VALUES[profile_idx][val_col_idx]) > f_rng_max) 
        	f_val = f_rng_max - VALUES[profile_idx][val_col_idx]; 
        }
        display_new = TRUE;
    }
    return f_val; 
} 

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function number_to_string(f_val,f_digits) {
/***********************************************************
 *  number_to_string(value to convert, # of digits in value)
 *
 *  Display Up to Max 16-bit Signed Integer (-32,768 to 32,767)
 *   
 *      Convert digits to ASCII
 *      Add ASCII character to print buffer
 *      Print string centered X & Y on OLED
 *  
***********************************************************/
    i = 1;  c_val = 10000;
    
	if(f_val < 0) //--neg numbers
	{          
         putc_oled(i,45);    //--add leading "-"
         i += 1;
         f_val = abs(f_val);
	} 
	
	for(c = 5; c >= 1; c--) 
	{
	    if(f_digits >= c) 
	    {
            putc_oled(i,ASCII_NUM[f_val / c_val]);
            f_val = f_val % c_val;
            i +=  1; 
            if(c == 4) 
            {
                putc_oled(i,44);   //--add ","
                i += 1;
            }
        }
        c_val /= 10;
    }   
    puts_oled(center_x(i - 1,OLED_FONT_LARGE_WIDTH),37,OLED_FONT_LARGE,i - 1,OLED_WHITE); // adjustable value centered in X
}  

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function find_digits(f_num) {
//  find_digits(value)  
//	    return Number of Digits in Value Passed  

    f_num = abs(f_num);
    if(f_num / 10000 > 0) return 5;
    if(f_num /  1000 > 0) return 4;
    if(f_num /   100 > 0) return 3;
    if(f_num /    10 > 0) return 2;
                          return 1;
}     

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function center_x(f_chars,f_font) {
//  center_x(number of chars,font size);  
//	    return X for Centering String Horizontally

    return (OLED_WIDTH / 2) - ((f_chars * f_font) / 2);
} 

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function center_y(f_size) {
//  center_y(font size);  
//	    return Y for Centering String Vertically

    return (OLED_HEIGHT  / 2) - (f_size / 2);
} 

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function press_hold(f_btn) { 
//  return TRUE - event_press()   
//			    - every 250ms when button is held

	return event_press(f_btn) || get_val(f_btn) && get_ptime(f_btn) > 250 
	       && get_ptime(f_btn) % (get_rtime() * 8) == 0;
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function led(f_color) {
   for(i = 0; i <= 3; i++) 
   {
     set_led(i,duint8((f_color * 4) + i));
   }
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 



// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function save () {
	combo_run(SAVE);
	
// Profile 1
	// Toggles                                      // Values
	set_pvar(SPVAR_1,toggle_antirecoil[0]);          set_pvar(SPVAR_6,antirecoil_vertical[0]);
	set_pvar(SPVAR_2,toggle_antirecoilh[0]);         set_pvar(SPVAR_7,antirecoil_horizontal[0]);
	set_pvar(SPVAR_3,toggle_rapidfire[0]);           set_pvar(SPVAR_8,antirecoil_start[0]):
	set_pvar(SPVAR_4,toggle_akimborf[0]);            set_pvar(SPVAR_9,antirecoil_end[0]);
	set_pvar(SPVAR_5,toggle_holdbreath[0]);          set_pvar(SPVAR_10,antirecoil_time[0]);
	                                                 set_pvar(SPVAR_11,horizontal_start[0]);
	                                                 set_pvar(SPVAR_12,horizontal_end[0]);
	                                                 set_pvar(SPVAR_13,horizontal_time[0]);
	                                                 set_pvar(SPVAR_14,rate_of_fire[0]);
	                                                 set_pvar(SPVAR_15,akimborf[0]);
//Profile 2
  //Toggles
  set_pvar(SPVAR_16,toggle_antirecoil[1]);           set_pvar(SPVAR_21,antirecoil_vertical[1]);
  set_pvar(SPVAR_17,toggle_antirecoilh[1]);          set_pvar(SPVAR_22,antirecoil_horizontal[1]);
  set_pvar(SPVAR_18,toggle_rapidfire[1]);            set_pvar(SPVAR_23,antirecoil_start[1]):
  set_pvar(SPVAR_19,toggle_akimborf[1]);             set_pvar(SPVAR_24,antirecoil_end[1]);
  set_pvar(SPVAR_20,toggle_holdbreath[1]);           set_pvar(SPVAR_25,antirecoil_time[1]);
	                                                 set_pvar(SPVAR_26,horizontal_start[1]);
	                                                 set_pvar(SPVAR_27,horizontal_end[1]);
	                                                 set_pvar(SPVAR_28,horizontal_time[1]);
	                                                 set_pvar(SPVAR_29,rate_of_fire[1]);
	                                                 set_pvar(SPVAR_30,akimborf[1]);
	                                                 
	
// Muilti toggles
    // Toggles only									 // Values
  set_pvar(SPVAR_31,sweetevil_on);                   set_pvar(SPVAR_42,Sampling_Time); 
  set_pvar(SPVAR_32,crescens_aim);                   set_pvar(SPVAR_43,Aim_Boost);
  set_pvar(SPVAR_33,polar_aim);                      set_pvar(SPVAR_44,Aim_Correction);      
  set_pvar(SPVAR_34,sticky_aim);                     set_pvar(SPVAR_45,Aim_Perfection_Limit);
  set_pvar(SPVAR_35,drop_shot);                      set_pvar(SPVAR_46,ingamesens);  
  set_pvar(SPVAR_36,snacks_sens);                    set_pvar(SPVAR_47,RADIUS);
  set_pvar(SPVAR_37,enemy_ping);                     set_pvar(SPVAR_48,STEPS);
  set_pvar(SPVAR_38,easy_plate);                     set_pvar(SPVAR_49,stickyaim_size);
  set_pvar(SPVAR_39,mp5comp_on);                     set_pvar(SPVAR_50,stickyaim_time); 
  set_pvar(SPVAR_40,mp5ar_on);                        set_pvar(SPVAR_51,drop_speed);
  set_pvar(SPVAR_41,uziAnti_on);                    set_pvar(SPVAR_52,GEN_SENS);
                                                     set_pvar(SPVAR_53,ADS_SENS);
                                                     set_pvar(SPVAR_54,FIRE_SENS);
                                                     set_pvar(SPVAR_55,ADS_FIRE_SENS);
                                                     set_pvar(SPVAR_56,GRENADE_SENS);
                                                     set_pvar(SPVAR_57,AutoSlideCancel_onoff);
                                                   		
    												
	
}


//-- Key Event Functions
int active_key, release_key, key_buffer, key_array[6];
function key_events(i, temp, continue,n){
  active_key = release_key = 0;
  if (key_buffer) {
    for(i = 0; i < 6; i++) {
      if (key_array[i] && !key_status(key_array[i])) {
        release_key = key_array[i];
        key_array[i] = 0;
        key_buffer--;
        break;
      }
    }
  }
  if (key_buffer < 6) {
    for(n = 4; n < 111; n++) {
    temp = n;
    if(n>=104) temp = (~0) << (n - 104);
      continue = 1;

      if (key_status(temp)) {
        for(i = 0; i < 6; i++) { if (key_array[i] == temp) {
            continue--; break;
          }
        }
        if(continue){
          for(i = 0; i < 6; i++) {
            if (!key_array[i]) {
              key_array[i] = temp;
              break;
            }
          }
          active_key = temp;
          key_buffer++;
        }
      }
    }
  }
  return;                              





}

//Functions
function key_status(key) { if(key < 0) return get_modifiers(inv(key)); return get_keyboard(key); }
function key_event_press(key)  { return key == active_key;  }
function key_event_release(key) { return key == release_key; }
define
KEY_LCTRL = -1,
KEY_LSHIFT = -2,
KEY_LALT = -4,
KEY_LGUI = -8,
KEY_RCTRL = -16,
KEY_RSHIFT = -32,
KEY_RALT = -64;

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 
/*
function block_btn() {

set_val(PS4_UP     , 0 ); 	set_val(PS4_DOWN  , 0 ); 	set_val(PS4_LEFT  , 0 );	set_val(PS4_RIGHT   , 0);
set_val(PS4_CROSS  , 0 ); 	set_val(PS4_CIRCLE, 0 ); 	set_val(PS4_SQUARE, 0 ); 	set_val(PS4_TRIANGLE, 0);
set_val(PS4_L1     , 0 ); 	set_val(PS4_R1    , 0 ); 	set_val(PS4_L3    , 0 ); 	set_val(PS4_R3      , 0);
set_val(PS4_OPTIONS, 0 ); 	set_val(PS4_SHARE , 0 );	set_val(PS4_TOUCH , 0 );	set_val(PS4_PS      , 0);
set_val(XB1_PL1    , 0 ); 	set_val(XB1_PL2   , 0 );	set_val(XB1_PR1   , 0 );	set_val(XB1_PR2     , 0);
//set_val(PS4_LX, 0); 		set_val(PS4_LY, 0); 		set_val(PS4_RX, 0); 		set_val(PS4_RY, 0);
//set_val(PS4_L1, 0); 		set_val(PS4_R1, 0);
}   */

function buttons_layout() {
	if (btn_layout == 0) // Default
	{
		JUMP_BTN      = PS4_CROSS;     TACTICAL_BTN  = PS4_L1;    
		CROUCH_BTN    = PS4_CIRCLE;    LETHAL_BTN    = PS4_R1; 
		RELOAD_BTN    = PS4_SQUARE;    ADS_BTN       = PS4_L2;
		SWITCH_BTN    = PS4_TRIANGLE;  FIRE_BTN      = PS4_R2;
									   SPRINT_BTN    = PS4_L3;
								       MELEE_BTN     = PS4_R3;
		if(flipped_on)
		{
		  ADS_BTN = PS4_L1;
		  FIRE_BTN = PS4_R1;
		}  
								       
	}
	else if (btn_layout == 1) // Tactical
	{
		JUMP_BTN      = PS4_CROSS;     TACTICAL_BTN  = PS4_L1;    
		MELEE_BTN     = PS4_CIRCLE;    LETHAL_BTN    = PS4_R1;
		RELOAD_BTN    = PS4_SQUARE;    ADS_BTN       = PS4_L2;
		SWITCH_BTN    = PS4_TRIANGLE;  FIRE_BTN      = PS4_R2;
									   SPRINT_BTN    = PS4_L3;
							       	   CROUCH_BTN    = PS4_R3;
		if(flipped_on)
		{
		  ADS_BTN = PS4_L1;
		  FIRE_BTN = PS4_R1;
		}  					       	   
	}
	else if (btn_layout == 2) // Lefty
	{
		JUMP_BTN      = PS4_CROSS;     TACTICAL_BTN  = PS4_L1;    
		CROUCH_BTN    = PS4_CIRCLE;    LETHAL_BTN    = PS4_R1; 
		RELOAD_BTN    = PS4_SQUARE;    ADS_BTN       = PS4_L2;
		SWITCH_BTN    = PS4_TRIANGLE;  FIRE_BTN      = PS4_R2;
									   MELEE_BTN     = PS4_L3;
									   SPRINT_BTN    = PS4_R3;
		if(flipped_on)
		{
		  ADS_BTN = PS4_L1;
		  FIRE_BTN = PS4_R1;
		}  							   
	}
	else if (btn_layout == 3) // N0M4D/Charlie
	{
		JUMP_BTN     = PS4_CROSS;     TACTICAL_BTN  = PS4_L1;   
		CROUCH_BTN   = PS4_CIRCLE;    ADS_BTN       = PS4_R1; 
		RELOAD_BTN   = PS4_SQUARE;    LETHAL_BTN    = PS4_L2;
		SWITCH_BTN   = PS4_TRIANGLE;  FIRE_BTN      = PS4_R2;
									  SPRINT_BTN    = PS4_L3;
								      MELEE_BTN     = PS4_R3;
		if(flipped_on)
		{
		  ADS_BTN = PS4_L1;
		  FIRE_BTN = PS4_R1;
		}  						      
	}
	else if (btn_layout == 4) // N0M4D/Charlie Tactical
	{
		JUMP_BTN      = PS4_CROSS;     TACTICAL_BTN  = PS4_L1;    
		MELEE_BTN     = PS4_CIRCLE;    ADS_BTN       = PS4_R1; 
		RELOAD_BTN    = PS4_SQUARE;    LETHAL_BTN    = PS4_L2;
		SWITCH_BTN    = PS4_TRIANGLE;  FIRE_BTN      = PS4_R2;
									   SPRINT_BTN    = PS4_L3;
								       CROUCH_BTN    = PS4_R3;
		if(flipped_on)
		{
		  ADS_BTN = PS4_L1;
		  FIRE_BTN = PS4_R1;
		}  						       
	}
	else if (btn_layout == 5) // N0M4D/Charlie Lefty
	{
		JUMP_BTN      = PS4_CROSS;     ADS_BTN       = PS4_L1; 
		CROUCH_BTN    = PS4_CIRCLE;    TACTICAL_BTN  = PS4_R1; 
		RELOAD_BTN    = PS4_SQUARE;    FIRE_BTN      = PS4_L2;
		SWITCH_BTN    = PS4_TRIANGLE;  LETHAL_BTN    = PS4_R2;
									   MELEE_BTN     = PS4_L3;
								       SPRINT_BTN    = PS4_R3;
		if(flipped_on)
		{
		  ADS_BTN = PS4_L1;
		  FIRE_BTN = PS4_R1;
		}  						       
	}
	else if (btn_layout == 6) // Bumper Jumper
	{
		TACTICAL_BTN  = PS4_CROSS;     JUMP_BTN      = PS4_L1;    
		CROUCH_BTN    = PS4_CIRCLE;    LETHAL_BTN    = PS4_R1; 
		RELOAD_BTN    = PS4_SQUARE;    ADS_BTN       = PS4_L2;
		SWITCH_BTN    = PS4_TRIANGLE;  FIRE_BTN      = PS4_R2;
									   SPRINT_BTN    = PS4_L3;
								       MELEE_BTN     = PS4_R3;
		if(flipped_on)
		{
		  ADS_BTN = PS4_L1;
		  FIRE_BTN = PS4_R1;
		}  						       
	}
	else if (btn_layout == 7) // Bumper Jumper Tactical
	{
		TACTICAL_BTN  = PS4_CROSS;     JUMP_BTN      = PS4_L1; 
		MELEE_BTN     = PS4_CIRCLE;    LETHAL_BTN    = PS4_R1; 
	    RELOAD_BTN    = PS4_SQUARE;    ADS_BTN       = PS4_L2;
		SWITCH_BTN    = PS4_TRIANGLE;  FIRE_BTN      = PS4_R2;
									   SPRINT_BTN    = PS4_L3;
								       CROUCH_BTN    = PS4_R3;
		if(flipped_on)
		{
		  ADS_BTN = PS4_L1;
		  FIRE_BTN = PS4_R1;
		}  						       
	}
	else if (btn_layout == 8) // One-Hand-Gunslinger
	{
		JUMP_BTN      = PS4_CROSS;     FIRE_BTN      = PS4_L1;    
		CROUCH_BTN    = PS4_CIRCLE;    TACTICAL_BTN  = PS4_R1; 
	    RELOAD_BTN    = PS4_SQUARE;    ADS_BTN       = PS4_L2;
		SWITCH_BTN    = PS4_TRIANGLE;  LETHAL_BTN    = PS4_R2;
									   SPRINT_BTN    = PS4_L3;
								       MELEE_BTN     = PS4_R3;
		if(flipped_on)
		{
		  ADS_BTN = PS4_L1;
		  FIRE_BTN = PS4_R1;
		}  						       
	}
	else if (btn_layout == 9) // Stick and Move
	{
		MELEE_BTN     = PS4_CROSS;     TACTICAL_BTN  = PS4_L1;    
		CROUCH_BTN    = PS4_CIRCLE;    LETHAL_BTN    = PS4_R1; 
		RELOAD_BTN    = PS4_SQUARE;    ADS_BTN       = PS4_L2;
		SWITCH_BTN    = PS4_TRIANGLE;  FIRE_BTN      = PS4_R2;
									   SPRINT_BTN    = PS4_L3;
								       JUMP_BTN      = PS4_R3;
		if(flipped_on)
		{
		  ADS_BTN = PS4_L1;
		  FIRE_BTN = PS4_R1;
		}  						       
	}
	else if (btn_layout == 10) // Brawler
	{
		JUMP_BTN      = PS4_CROSS;     TACTICAL_BTN  = PS4_L1;    
		CROUCH_BTN    = PS4_CIRCLE;    MELEE_BTN     = PS4_R1; 
		RELOAD_BTN    = PS4_SQUARE;    ADS_BTN       = PS4_L2;
		SWITCH_BTN    = PS4_TRIANGLE;  FIRE_BTN      = PS4_R2;
									   SPRINT_BTN    = PS4_L3;
								       LETHAL_BTN    = PS4_R3;
		if(flipped_on)
		{
		  ADS_BTN = PS4_L1;
		  FIRE_BTN = PS4_R1;
		}  						       
	}
	else if (btn_layout == 11) // Beast
	{
		TACTICAL_BTN  = PS4_CROSS;     JUMP_BTN      = PS4_L1;    
		CROUCH_BTN    = PS4_CIRCLE;    MELEE_BTN     = PS4_R1; 
		RELOAD_BTN    = PS4_SQUARE;    ADS_BTN       = PS4_L2;
		SWITCH_BTN    = PS4_TRIANGLE;  FIRE_BTN      = PS4_R2;
									   SPRINT_BTN    = PS4_L3;
								       LETHAL_BTN    = PS4_R3;
		if(flipped_on)
		{
		  ADS_BTN = PS4_L1;
		  FIRE_BTN = PS4_R1;
		}  						       
	}
}
